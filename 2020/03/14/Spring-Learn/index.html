<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="hecn">
  <meta name="keywords" content="">
  <title>Spring-Learn - hecn的博客</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>hecn的博客</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期六, 三月 14日 2020, 9:07 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    8.1k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      39 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
            <div class="markdown-body">
              <h1 id="1、Spring"><a href="#1、Spring" class="headerlink" title="1、Spring"></a>1、Spring</h1><h2 id="1-1、简介"><a href="#1-1、简介" class="headerlink" title="1.1、简介"></a>1.1、简介</h2><ul>
<li>Spring：春天——&gt;给Java开发带来了春天；</li>
<li>2002，首次推出Spring框架的雏形：interface21框架！</li>
<li>Spring框架以interface21框架为基础，经过设计，不断丰富，于2004连3月24日发布了1.0正式版。</li>
<li>Spring Framework创始人，著名作者。</li>
<li>Spring：使现有的技术更加容易使用，本身是一一个大杂烩，整合了现有的技术框架。</li>
<li>SSH:Struct2+Spring+Hibernate</li>
<li>SSM:SpringMvc+Spring+Mybatis</li>
</ul>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="1-2、优点"><a href="#1-2、优点" class="headerlink" title="1.2、优点"></a>1.2、优点</h2><ul>
<li>Spring是一个开源的免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵的框架</li>
<li>控制反转（ioc），面写切面编程（aop）</li>
<li>支持事务的处理对框架整合的支持</li>
</ul>
<p>==总结Spring是一个轻量级的控制反转和面向切面编程的框架==</p>
<h2 id="1-3、组成"><a href="#1-3、组成" class="headerlink" title="1.3、组成"></a>1.3、组成</h2><p> <img src="https://gitee.com/hecn/hexo_picture_bed/raw/master/imags/Spring%E7%BB%84%E6%88%90.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="1-4、扩展"><a href="#1-4、扩展" class="headerlink" title="1.4、扩展"></a>1.4、扩展</h2><p>现代化的Java开发：基于“Spring”的开发</p>
<ul>
<li>springboot</li>
<li>springcloud</li>
</ul>
<h1 id="2、IOC-控制反转"><a href="#2、IOC-控制反转" class="headerlink" title="2、IOC(控制反转)"></a>2、IOC(控制反转)</h1><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法</strong>，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p><strong>IoC是spring框架的核心内容</strong>，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
<h1 id="3、HelloSpring"><a href="#3、HelloSpring" class="headerlink" title="3、HelloSpring"></a>3、HelloSpring</h1><h2 id="3-1、创建一个maven项目（导入jar包）"><a href="#3-1、创建一个maven项目（导入jar包）" class="headerlink" title="3.1、创建一个maven项目（导入jar包）"></a>3.1、创建一个maven项目（导入jar包）</h2><pre><code class="xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre>
<h2 id="3-2、编写代码"><a href="#3-2、编写代码" class="headerlink" title="3.2、编写代码"></a>3.2、编写代码</h2><p>1.编写一个实体类:</p>
<pre><code class="java">package com.chen.pojo;

public class Hello {
  private String str;

  public String getStr() {
    return str;
  }

  public void setStr(String str) {
    this.str = str;
  }

  @Override
  public String toString() {
    return &quot;Hello{&quot; + &quot;str=&#39;&quot; + str + &#39;\&#39;&#39; + &#39;}&#39;;
  }
}</code></pre>
<p>2.编写spring文件，命名为<strong>applicationContext</strong>.xml:</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--    使用spring来创建对象，在spring中这些都称为Bean--&gt;
    &lt;bean id=&quot;hello&quot; class=&quot;com.chen.pojo.Hello&quot;&gt;
        &lt;property name=&quot;str&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
<p>3.测试类：</p>
<pre><code class="java">package com.chen.pojo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class HelloTest {
  public static void main(String[] args) {

    //      实例化容器
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    //      从容器中取bean
    Hello hello = (Hello) context.getBean(&quot;hello&quot;);

    System.out.println(hello.toString());
    //hello.toString();
  }
}</code></pre>
<h1 id="4、IoC创建对象的方式"><a href="#4、IoC创建对象的方式" class="headerlink" title="4、IoC创建对象的方式"></a>4、IoC创建对象的方式</h1><h2 id="4-1、使用无参构造创建对象（默认方式）"><a href="#4-1、使用无参构造创建对象（默认方式）" class="headerlink" title="4.1、使用无参构造创建对象（默认方式）"></a>4.1、使用无参构造创建对象（默认方式）</h2><h2 id="4-2、若使用有参构造创建对象"><a href="#4-2、若使用有参构造创建对象" class="headerlink" title="4.2、若使用有参构造创建对象"></a>4.2、若使用有参构造创建对象</h2><p>1.构造函数参数索引匹配</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;!--
      构造函数参数索引==下标赋值
      --&gt;
    &lt;bean id=&quot;user&quot; class=&quot;com.hecn.pojo.User&quot;&gt;
        &lt;constructor-arg index=&quot;0&quot; value=&quot;000000&quot;&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
<p>2.构造函数参数类型匹配(<strong>不建议使用</strong>)</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--
      构造函数参数类型匹配
      不建议使用
    --&gt;
    &lt;bean id=&quot;user2&quot; class=&quot;com.hecn.pojo.User&quot;&gt;
        &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;参数类型&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>3.参数解析（直接通过参数名设置）</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!--
    构造函数参数解析(直接通过参数名设置)
    --&gt;
    &lt;bean id=&quot;user3&quot; class=&quot;com.hecn.pojo.User&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;name&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p><strong><em>总结：</em></strong></p>
<p><strong>在配置文件加载的时候，容器中管理的对象就已经初始化了！</strong></p>
<h1 id="5、Spring配置"><a href="#5、Spring配置" class="headerlink" title="5、Spring配置"></a>5、Spring配置</h1><h2 id="5-1、Alias-别名"><a href="#5-1、Alias-别名" class="headerlink" title="5.1、Alias(别名)"></a>5.1、Alias(别名)</h2><pre><code class="xml">    &lt;!--别名 name：原有名；
            alias：别名。
    --&gt;
    &lt;alias name=&quot;user&quot; alias=&quot;user4&quot;/&gt;</code></pre>
<h2 id="5-2、Bean的配置"><a href="#5-2、Bean的配置" class="headerlink" title="5.2、Bean的配置"></a>5.2、Bean的配置</h2><pre><code class="xml">&lt;!--
id:bean的唯一标识符，
class：bean对象所对应的全限定名：包名+类型
name:也是别名，而且name可以取多个别名
    --&gt;
&lt;bean id=&quot;userT1&quot; class=&quot;com.hecn.pojo.UserT&quot; name=&quot;u2,u3 u4;u5&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;hehe&quot;/&gt;
&lt;/bean&gt;</code></pre>
<h2 id="5-3、import"><a href="#5-3、import" class="headerlink" title="5.3、import"></a>5.3、import</h2><pre><code class="xml">&lt;!--
一般用于团队开发，它可以将多个配置文件，导入并合并为一个总的配置
--&gt;
&lt;import resource=&quot;applicationContext2.xml&quot;/&gt;
&lt;import resource=&quot;applicationContext3.xml&quot;/&gt;</code></pre>
<h1 id="6、依赖注入"><a href="#6、依赖注入" class="headerlink" title="6、依赖注入"></a>6、依赖注入</h1><h2 id="6-1、构造器注入"><a href="#6-1、构造器注入" class="headerlink" title="6.1、构造器注入"></a>6.1、构造器注入</h2><p><strong>见4.2</strong></p>
<h2 id="6-2、Set方式注入"><a href="#6-2、Set方式注入" class="headerlink" title="6.2、Set方式注入"></a>6.2、Set方式注入</h2><ul>
<li>依赖注入：set注入<ul>
<li>依赖：bean对象的创建依赖于容器！</li>
<li>注入：bean对象中的所有属性，由容器来注入！</li>
</ul>
</li>
</ul>
<p><strong>【环境搭建】</strong></p>
<p> 1.复杂类型</p>
<pre><code class="java">package com.hecn.pojo;

public class Adress {
    private String adress;

    public Adress(String adress) {
        this.adress = adress;
    }

    public String getAdress() {
        return adress;
    }

    public void setAdress(String adress) {
        this.adress = adress;
    }
}
</code></pre>
<ol start="2">
<li>真实测试对象</li>
</ol>
<pre><code class="java">package com.hecn.pojo;

import lombok.Data;

import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/** @author 24497 */
@Data // 使用了lombook插件

public class Student {
  //    字符串
  private String name;
  //    引用
  private Adress adress;
  //    集合
  private String[] books;
  //    列表
  private List&lt;String&gt; hobbys;
  //    Map
  private Map&lt;String, String&gt; card;
  //    Set
  private Set&lt;String&gt; games;
  //    Null
  private String wife;
  //    Props
  private Properties info;
}</code></pre>
<p>3.beans.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;student&quot; class=&quot;com.hecn.pojo.Student&quot;&gt;
        &lt;!--普通值注入        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;!--&lt;property name=&quot;adress&quot; ref=&quot;&quot;&gt;&lt;/property&gt;--&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<p>4.测试类</p>
<pre><code class="java">package com.hecn.pojo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class StudentTest {
  public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    Student student = (Student) context.getBean(&quot;student&quot;);
    System.out.println(student.getName());
  }
}</code></pre>
<p>5.完善注入信息</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;address&quot; class=&quot;com.hecn.pojo.Address&quot;&gt;
        &lt;property name=&quot;address&quot; value=&quot;荆州&quot;/&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;student&quot; class=&quot;com.hecn.pojo.Student&quot;&gt;
        &lt;!--1.普通值注入,value        --&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;&gt;&lt;/property&gt;
        &lt;!--2.Bean注入,ref        --&gt;
        &lt;property name=&quot;address&quot; ref=&quot;address&quot;&gt;&lt;/property&gt;
        &lt;!--3.数组注入,       --&gt;
        &lt;property name=&quot;books&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;红楼梦&lt;/value&gt;
                &lt;value&gt;三国演义&lt;/value&gt;
                &lt;value&gt;西游记&lt;/value&gt;
                &lt;value&gt;水浒传&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--4.List注入, --&gt;
        &lt;property name=&quot;hobbys&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;听歌&lt;/value&gt;
                &lt;value&gt;敲代码&lt;/value&gt;
                &lt;value&gt;学英语&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--4.List注入, --&gt;
        &lt;property name=&quot;card&quot;&gt;
            &lt;map&gt;
                &lt;entry key=&quot;身份证&quot; value=&quot;123456&quot;/&gt;
                &lt;entry key=&quot;银行卡&quot; value=&quot;23455667&quot;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;!--5.Set注入, --&gt;
        &lt;property name=&quot;games&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;LOL&lt;/value&gt;
                &lt;value&gt;OW&lt;/value&gt;
                &lt;value&gt;饥荒&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--6.空字符串, --&gt;
        &lt;property name=&quot;gongzi&quot; value=&quot;&quot;/&gt;

        &lt;!--7.null, --&gt;
        &lt;property name=&quot;wife&quot;&gt;
            &lt;null/&gt;
        &lt;/property&gt;

        &lt;!--8.Properties, --&gt;
        &lt;property name=&quot;info&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;name&quot;&gt;陈&lt;/prop&gt;
                &lt;prop key=&quot;no&quot;&gt;201640450114&lt;/prop&gt;
                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre>
<h2 id="6-3、其他方式（拓展方式）"><a href="#6-3、其他方式（拓展方式）" class="headerlink" title="6.3、其他方式（拓展方式）"></a>6.3、其他方式（拓展方式）</h2><p>我们可以使用p命名空间和c命名空间进行注入</p>
<p>官方解释：</p>
<ul>
<li>使用：</li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:c=&quot;http://www.springframework.org/schema/c&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;bean id=&quot;user&quot; class=&quot;com.hecn.pojo.User&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;张三&quot;/&gt;
        &lt;property name=&quot;age&quot; value=&quot;24&quot;/&gt;
    &lt;/bean&gt;

    &lt;bean id=&quot;user2&quot; class=&quot;com.hecn.pojo.User&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;狄仁杰&quot;&gt;&lt;/constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;21&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;

    &lt;!--p命名空间，可以直接注入属性的值：property    --&gt;
    &lt;bean id=&quot;userP&quot; class=&quot;com.hecn.pojo.User&quot; p:name=&quot;李四&quot; p:age=&quot;26&quot;/&gt;

    &lt;!--c命名空间，通过构造器注入：construct-args    --&gt;
    &lt;bean id=&quot;userC&quot; class=&quot;com.hecn.pojo.User&quot; c:name=&quot;\(@^0^@)/&quot; c:age=&quot;21&quot;/&gt;

&lt;/beans&gt;</code></pre>
<ul>
<li>测试：</li>
</ul>
<pre><code class="java">package com.hecn.pojo;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import java.util.*;

public class StudentTest {
  @Test
  public void MyTest() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext2.xml&quot;);
    User user = (User) context.getBean(&quot;user&quot;);
    User user2 = (User) context.getBean(&quot;user2&quot;);
    //User userP = context.getBean(&quot;user3&quot;, User.class);
    //User userC = context.getBean(&quot;user3&quot;, User.class);
    System.out.println(user2.toString());
    System.out.println(user.toString());
    //System.out.println(userP.toString());
    //System.out.println(userC.toString());

  }
}</code></pre>
<ul>
<li>注意点：p,c命名空间需要导入xml约束才能使用</li>
</ul>
<pre><code class="xml">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</code></pre>
<h2 id="6-4、Bean的作用域（Bean）"><a href="#6-4、Bean的作用域（Bean）" class="headerlink" title="6.4、Bean的作用域（Bean）"></a>6.4、Bean的作用域（Bean）</h2><table>
<thead>
<tr>
<th align="left">Scope</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">singleton</td>
<td align="left">(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">Scopes a single bean definition to any number of object instances.</td>
</tr>
<tr>
<td align="left">request</td>
<td align="left">Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left">session</td>
<td align="left">Scopes a single bean definition to the lifecycle of an HTTP <code>Session</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left">application</td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>ServletContext</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
<tr>
<td align="left">websocket</td>
<td align="left">Scopes a single bean definition to the lifecycle of a <code>WebSocket</code>. Only valid in the context of a web-aware Spring <code>ApplicationContext</code>.</td>
</tr>
</tbody></table>
<p>1.<strong>singleton</strong>单例模式（Spring默认机制）</p>
<pre><code class="xml">    &lt;bean id=&quot;userP&quot; class=&quot;com.hecn.pojo.User&quot; p:name=&quot;李四&quot; p:age=&quot;26&quot; scope=&quot;singleton&quot;/&gt;</code></pre>
<p>2.<strong>prototype</strong>原型模式：每次从容器中get的时候都会产生一个新对象</p>
<pre><code class="xml">    &lt;bean id=&quot;userC&quot; class=&quot;com.hecn.pojo.User&quot; c:name=&quot;\(@^0^@)/&quot; c:age=&quot;21&quot; scope=&quot;prototype&quot;/&gt;</code></pre>
<p>3.其余的request，session，application这些只能在web开发中使用到！</p>
<h1 id="7、Bean的自动装配"><a href="#7、Bean的自动装配" class="headerlink" title="7、Bean的自动装配"></a>7、Bean的自动装配</h1><ul>
<li>Bean的自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在spring中有三种自动装配的方式</p>
<p><strong>1.在xml显示的配置</strong></p>
<p><strong>2.在Java中显示配置</strong></p>
<p><strong>3.隐示的自动装配【重要】</strong></p>
<h2 id="7-1、测试"><a href="#7-1、测试" class="headerlink" title="7.1、测试"></a>7.1、测试</h2><p>环境搭建：一个人有两个宠物</p>
<h2 id="7-2、ByName自动装配"><a href="#7-2、ByName自动装配" class="headerlink" title="7.2、ByName自动装配"></a>7.2、ByName自动装配</h2><pre><code class="xml">&lt;!--ByName自动装配
       会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid--&gt;
    &lt;bean id=&quot;peopleAutowire&quot; class=&quot;com.hecn.pojo.People&quot; autowire=&quot;byName&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;
    &lt;/bean&gt;</code></pre>
<h2 id="7-3、ByType自动装配"><a href="#7-3、ByType自动装配" class="headerlink" title="7.3、ByType自动装配"></a>7.3、ByType自动装配</h2><pre><code class="xml">&lt;!--ByName自动装配
       会自动在容器上下文中查找，和自己对象set方法后面的值对应的beanid
    ByType:会自动在容器上下文查找，和自己对象属性类型相同的bean
--&gt;
    &lt;bean id=&quot;peopleAutowire&quot; class=&quot;com.hecn.pojo.People&quot; autowire=&quot;byType&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;李四&quot;/&gt;
    &lt;/bean&gt;</code></pre>
<p>小结：</p>
<ul>
<li><p>byName的时候需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法一致</p>
</li>
<li><p>byType的时候需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</p>
</li>
</ul>
<h2 id="7-4、使用注解实现自动装配"><a href="#7-4、使用注解实现自动装配" class="headerlink" title="7.4、使用注解实现自动装配"></a>7.4、使用注解实现自动装配</h2><p>jdk1.5支持的注解，Spring2.5就支持注解了</p>
<p>我们使用注解须知：</p>
<ol>
<li><p>导入约束：context的约束 xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a></p>
</li>
<li><p>==配置注解的支持：<a href="context:annotation-config/">context:annotation-config/</a>==</p>
</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;context:annotation-config/&gt;

&lt;/beans&gt;</code></pre>
<p><strong>@Autowired</strong></p>
<ul>
<li><p>它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。 通过 @Autowired的使用来消除 set ，get方法。</p>
</li>
<li><p>@Autowired是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合<strong>@Qualifier</strong>使用；</p>
</li>
<li><p>==@Autowired @Qualifier=byType||byName==</p>
</li>
<li><p><strong>@Autowired</strong>(required = <strong>false</strong>)处理空指针</p>
</li>
</ul>
<pre><code class="java"> @Autowired
  private Cat cat;</code></pre>
<p><strong>@Resource</strong></p>
<pre><code class="java">@Resource(name = &quot;dog11&quot;)
private Dog dog;</code></pre>
<p><strong>小结：</strong></p>
<ul>
<li><strong>@Resource</strong>和<strong>@Autowired</strong>注解都是用来自动装配的；</li>
<li><strong>@AutoWried</strong>按by type自动装配；</li>
<li><strong>@Resource</strong>默认按byName装配，找不到这通过byType实现；</li>
</ul>
<p><strong>它们的主要区别就是@Autowired是默认按照类型装配的 @Resource默认是按照名称装配的</strong></p>
<h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><ul>
<li><strong>在spring4之后，想要使用注解形式，必须得要引入aop的包</strong></li>
</ul>
<p><a href="">Maven: org.springframework:spring- aop:4.3.9.RELEASE</a></p>
<ul>
<li><strong>在配置文件当中，还得要引入一个context约束</strong></li>
</ul>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</code></pre>
<h2 id="8-1、bean"><a href="#8-1、bean" class="headerlink" title="8.1、bean"></a>8.1、bean</h2><!--指定注解扫描包--> <context:component-scan base-package="com.kuang.pojo"/>

<h2 id="8-2、属性如何注入"><a href="#8-2、属性如何注入" class="headerlink" title="8.2、属性如何注入"></a>8.2、属性如何注入</h2><pre><code class="java">package com.hecn.pojo;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

/** @author 24497 */
@Component // 等价于&lt;bean id=&quot;user&quot; class=&quot;com.hecn.pojo.User&quot;/&gt;
public class User {
  /** 相当于&lt;property name=&quot;name&quot; value=&quot;\(@^0^@)/&quot;/&gt; */
  @Value(&quot;\\(@^0^@)/&quot;)
  public String name;
}
</code></pre>
<h2 id="8-3、衍生的注解"><a href="#8-3、衍生的注解" class="headerlink" title="8.3、衍生的注解"></a>8.3、衍生的注解</h2><p><strong>@Component</strong>（组件）有几个衍生的注解</p>
<ul>
<li>dao【<strong>@Repository</strong>】</li>
<li>service【<strong>@Service</strong>】</li>
<li>controller【<strong>@Controller</strong>】</li>
</ul>
<p>这四个功能一样，把某个类注册到Spring容器中，准备bean。</p>
<h2 id="8-4、自动装配置"><a href="#8-4、自动装配置" class="headerlink" title="8.4、自动装配置"></a>8.4、自动装配置</h2><h2 id="8-5、作用域"><a href="#8-5、作用域" class="headerlink" title="8.5、作用域"></a>8.5、作用域</h2><pre><code class="java">@Component // 等价于&lt;bean id=&quot;user&quot; class=&quot;com.hecn.pojo.User&quot;/&gt;
@Scope(&quot;singleton&quot;)
public class User {
  /** 相当于&lt;property name=&quot;name&quot; value=&quot;\(@^0^@)/&quot;/&gt; */
  @Value(&quot;\\(@^0^@)/&quot;)
  public String name;
}</code></pre>
<h2 id="8-6、小结"><a href="#8-6、小结" class="headerlink" title="8.6、小结"></a>8.6、小结</h2><p>xml与注解：</p>
<ul>
<li>xml万能，适用于任何场所，维护简单方便</li>
<li>注解不是自己的类使用不了，维护相对复杂</li>
</ul>
<p>xml与注解的最佳实践：</p>
<ul>
<li>xml用来管理bean；</li>
<li>注解只负责完成属性的注入；</li>
<li>我们在使用的过程中，只需要注意一个问题: 必须让注解生效,就需要开启注解的支持</li>
</ul>
<pre><code class="xml">    &lt;context:component-scan base-package=&quot;xx.xx.xx&quot;/&gt;
    &lt;context:annotation-config/&gt;</code></pre>
<h1 id="9、使用Java的方式配置spring"><a href="#9、使用Java的方式配置spring" class="headerlink" title="9、使用Java的方式配置spring"></a>9、使用Java的方式配置spring</h1><p>我们现在要完全不使用Spring的xml配置了，全权交给Java来做!</p>
<p>JavaConfig是Spring的一个子项目,在Spring4之后，它成为了一个核心功能!</p>
<p>实体类：</p>
<pre><code class="java">package com.hecn.pojo;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
@Getter
@Setter
@ToString
public class User {
    @Value(&quot;李四&quot;)
    private String name;

}</code></pre>
<p>配置类:</p>
<pre><code class="java">package com.hecn.config;

import com.hecn.pojo.User;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;


@Configuration
/** 等价于applicationContext.xml */
@ComponentScan(&quot;com.hecn.pojo&quot;)
@Import(HecnConfig2.class)
public class HecnConfig {

  /**
   * @return 1.注册一个bean，相当于bean标签&lt;bean&gt;&lt;bean/&gt;； 2.方法名相当于&lt;bean id=&quot;user&quot;&gt;&lt;/bean&gt;中的id属性； 3.返回值相当于&lt;bean
   *     class=&quot;com.hecn.pojo.User&quot;&gt;&lt;/bean&gt;中的class属性。
   */
  @Bean
  public User user() {
    //    就是返回要注入到bean的对象
    return new User();
  }
}</code></pre>
<p>测试类：</p>
<pre><code class="java">import com.hecn.config.HecnConfig;
import com.hecn.pojo.User;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class MyTest {
  @Test
  public void myTest() {

    ApplicationContext context = new AnnotationConfigApplicationContext(HecnConfig.class);

    User user = context.getBean(&quot;user&quot;, User.class);
    System.out.println(user.toString());
  }
}</code></pre>
<p><strong>这种纯Java的配置方式，在SpringBoot中随处可见!</strong></p>
<h1 id="10、代理模式"><a href="#10、代理模式" class="headerlink" title="10、代理模式"></a>10、代理模式</h1><p>why？因为这就是SpringAOP的底层! </p>
<p>代理模式的分类：代理模式分为静态代理、动态代理。</p>
<ul>
<li><p>静态代理是由程序员创建或工具生成代理类的源码，再编译代理类。所谓静态也就是在程序运行前就已经存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。</p>
</li>
<li><p>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。    </p>
</li>
</ul>
<h2 id="10-1、静态代理"><a href="#10-1、静态代理" class="headerlink" title="10.1、静态代理"></a>10.1、静态代理</h2><p><strong>角色分析：</strong></p>
<ul>
<li><p>抽象角色：通过接口或抽象类声明真实角色实现的业务方法。</p>
</li>
<li><p>真实角色：被代理的角色，实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。</p>
</li>
<li><p>代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。</p>
</li>
<li><p>客户：访问代理对象的人</p>
</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>可以使真实角色的操作更纯粹，不用去关注共工业务；</li>
<li>公共也就就交给代理角色!实现了业务的分工!</li>
<li>公共业务发生扩展的时候，方便集中管理!</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>一个真实角色就会产生一 个代理角色;代码量会翻倍~ 开发效率会变低 ~</li>
</ul>
<p><strong>代码实现：</strong></p>
<ol>
<li>抽象角色：Rent.java</li>
</ol>
<pre><code class="java">package com.hecn.demo;

/**
 * 租房
 * @author 24497
 */
public interface Rent {
    public void rent();
}</code></pre>
<ol start="2">
<li>真实角色：Host.java</li>
</ol>
<pre><code class="java">package com.hecn.demo;

/** @author 24497 */
public class Host implements Rent {
  public void rent() {
    System.out.println(&quot;房东要出租房子&quot;);
  }
}
</code></pre>
<ol start="3">
<li>代理角色：Proxy.java</li>
</ol>
<pre><code class="java">package com.hecn.demo01;

import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

/** 中介 @author 24497 */
@NoArgsConstructor
@AllArgsConstructor
public class Proxy implements Rent {
  private Host host;

  public void rent() {
    host.rent();
  }

  // 看房
  public void seeHouse() {
    System.out.println(&quot;带你看房&quot;);
  }

  // 收取中介费用
  public void fare() {
    System.out.println(&quot;收取中介费&quot;);
  }

  // 合同
  public void hetong() {
    System.out.println(&quot;合同&quot;);
  }
}</code></pre>
<ol start="4">
<li>客户:Client.java</li>
</ol>
<pre><code class="java">package com.hecn.demo01;

/**
 * 客户
 *
 * @author 24497
 */
public class Client {
  public static void main(String[] args) {
    // 房东
    Host host = new Host();
    // 代理==中介，附属操作
    Proxy proxy = new Proxy(host);

    // 直接找中介
    proxy.rent();
  }
}</code></pre>
<h2 id="10-2、动态代理"><a href="#10-2、动态代理" class="headerlink" title="10.2、动态代理"></a>10.2、动态代理</h2><ul>
<li>动态代理的角色和静态代理的一样 .</li>
<li>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</li>
<li>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理<ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . </li>
<li>我们这里使用JDK的原生代码来实现，其余的道理都是一样的！</li>
</ul>
</li>
</ul>
<p>Proxy:代理，InvocationHandler：调用处理程序</p>
<p><strong>InvocationHandler</strong></p>
<p><strong>动态代理的好处</strong></p>
<p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h1 id="11、AOP"><a href="#11、AOP" class="headerlink" title="11、AOP"></a>11、AOP</h1><h2 id="11-1、什么是aop？"><a href="#11-1、什么是aop？" class="headerlink" title="11.1、什么是aop？"></a>11.1、什么是aop？</h2><p>​    在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过==预编译==方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是<a href="https://baike.baidu.com/item/Spring" target="_blank" rel="noopener">Spring</a>框架中的一个重要内容，是==函数式编程==的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<h2 id="11-2、aop在Spring中的作用"><a href="#11-2、aop在Spring中的作用" class="headerlink" title="11.2、aop在Spring中的作用"></a>11.2、aop在Spring中的作用</h2><p><strong>提供声明式事务；允许用户自定义切面</strong></p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</li>
<li>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</li>
<li>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</li>
<li>目标（Target）：被通知对象。</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象。</li>
<li>切入点（PointCut）：切面通知 执行的 “地点”的定义。</li>
<li>连接点（JointPoint）：与切入点匹配的执行点。</li>
</ul>
<p><strong>SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:</strong></p>
<table>
<thead>
<tr>
<th align="left">通知类型</th>
<th align="center">连接点</th>
<th align="right">实现接口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">前置通知Before</td>
<td align="center">方法前</td>
<td align="right">org.springframework.aop.MethodBeforeAdvice</td>
</tr>
<tr>
<td align="left">后置通知After</td>
<td align="center">方法后</td>
<td align="right">org.springframework.aop.AfterReturningAdvice</td>
</tr>
<tr>
<td align="left">环绕通知Around</td>
<td align="center">方法前后</td>
<td align="right">org.aopalliance.intercept.MethodInterceptor</td>
</tr>
<tr>
<td align="left">异常通知After-throwing</td>
<td align="center">方法抛出异常</td>
<td align="right">org.springframework.aop.ThrowsAdvice</td>
</tr>
<tr>
<td align="left">返回通知After-returning</td>
<td align="center">方法成功后</td>
<td align="right">org.springframework.aop.IntroductionInterceptor</td>
</tr>
</tbody></table>
<p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 。</p>
<h2 id="11-3、使用spring实现aop"><a href="#11-3、使用spring实现aop" class="headerlink" title="11.3、使用spring实现aop"></a>11.3、使用spring实现aop</h2><p>【重点】使用AOP织入，需要导入一个依赖包！</p>
<pre><code class="xml">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
<h3 id="方式一：使用SpringAPI借口实现"><a href="#方式一：使用SpringAPI借口实现" class="headerlink" title="方式一：使用SpringAPI借口实现"></a>方式一：使用SpringAPI借口实现</h3><ol>
<li>编写业务接口类和实现类（UserService.interface）</li>
</ol>
<pre><code class="java">package com.hecn.service;

/**
 * @author 24497
 */
public interface UserService {
    public void add();
    public void delete();
    public void update();
    public void selete();
}</code></pre>
<pre><code class="java">package com.hecn.service;

/**
 * @author 24497
 */
public class UserServiceImpl implements UserService {

  public void add() {
    System.out.println(&quot;增加了一个用户&quot;);
  }

  public void delete() {
    System.out.println(&quot;删除了一个用户&quot;);
  }

  public void update() {
    System.out.println(&quot;更新了一个用户&quot;);
  }

  public void selete() {
    System.out.println(&quot;查询了一个用户&quot;);
  }
}</code></pre>
<ol start="2">
<li>增强类，</li>
</ol>
<pre><code class="java">package com.hecn.log;

import org.springframework.aop.MethodBeforeAdvice;

import java.lang.reflect.Method;

/** 前置增强 @author 24497 */
public class Log implements MethodBeforeAdvice {
  /**
   * @param method 要执行目标对象的方法
   * @param args   参数
   * @param target 目标对象
   * @throws Throwable
   */
  public void before(Method method, Object[] args, Object target) throws Throwable {
    System.out.println(target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;被执行了。&quot;);
  }
}</code></pre>
<pre><code class="java">package com.hecn.log;

import org.springframework.aop.AfterReturningAdvice;

import java.lang.reflect.Method;

/**
 * 方法执行成功后返回通知
 * 后置方法
 * @author 24497
 */
public class AfterLog implements AfterReturningAdvice {
  /**
   *
   * @param returnValue 执行方法后返回的值（如果有）
   * @param method 被调用的方法
   * @param args 参数
   * @param target target of the method invocation. May be {@code null}.
   * @throws Throwable if this object wishes to abort the call. Any exception thrown will be
   *     returned to the caller if it&#39;s allowed by the method signature. Otherwise the exception
   *     will be wrapped as a runtime exception.
   */
  public void afterReturning(Object returnValue, Method method, Object[] args, Object target)
      throws Throwable {
    System.out.println(&quot;执行了&quot; + method.getName() + &quot;方法,返回结果为&quot; + returnValue);
  }
}</code></pre>
<ol start="3">
<li>bean的注册以及aop的配置(注意导入约束)</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--    注册bean--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.hecn.service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;com.hecn.log.Log&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;com.hecn.log.AfterLog&quot;&gt;&lt;/bean&gt;
    &lt;!--    方式一：使用原生的apringapi接口--&gt;
    &lt;!--    配置aop:需要导入aop约束--&gt;
    &lt;aop:config&gt;
    &lt;!--切入点: expression:表达式,execution(要执行的位置！) For example : &#39;execution(* com.xyz.myapp.service.*.*(..))&#39;--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.hecn.service.UserServiceImpl.*(..))&quot;/&gt;

     &lt;!--        执行环绕增加--&gt;
        &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:config&gt;
&lt;/beans&gt;


</code></pre>
<ol start="4">
<li>测试</li>
</ol>
<pre><code class="java">import com.hecn.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
  public static void main(String[] args) {
      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

      UserService userService = (UserService) context.getBean(&quot;userService&quot;);

      userService.add();
  }
}</code></pre>
<p>Aop的重要性 : 很重要 . 一定要理解其中的思路 , 主要是思想的理解这一块 .</p>
<p>Spring的Aop就是将公共的业务 (日志 , 安全等) 和领域业务结合起来 , 当执行领域业务时 , 将会把公共业务加进来 . 实现公共业务的重复利用 . 领域业务更纯粹 , 程序猿专注领域业务 , 其本质还是动态代理 .</p>
<h3 id="方式二：自定义来实现（切面定义）"><a href="#方式二：自定义来实现（切面定义）" class="headerlink" title="方式二：自定义来实现（切面定义）"></a>方式二：自定义来实现（切面定义）</h3><p>目标业务类不变依旧是userServiceImpl</p>
<ol>
<li>写我们自己的一个切入类:diyPointCut.java</li>
</ol>
<pre><code class="java">package com.hecn.diy;

public class DiyPiontCut {

  public void before() {
    System.out.println(&quot;===============方法执行前===============&quot;);
  }

  public void after() {
    System.out.println(&quot;===============方法执行后===============&quot;);
  }
}</code></pre>
<ol start="2">
<li>spring配置aop配置</li>
</ol>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

    &lt;!--    注册bean--&gt;
    &lt;bean id=&quot;userService&quot; class=&quot;com.hecn.service.UserServiceImpl&quot;/&gt;
    &lt;bean id=&quot;log&quot; class=&quot;com.hecn.log.Log&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;afterLog&quot; class=&quot;com.hecn.log.AfterLog&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;diy&quot; class=&quot;com.hecn.diy.DiyPiontCut&quot;/&gt;

    &lt;!--方式二:自定义类--&gt;

    &lt;aop:config&gt;
        &lt;!-- 自定义切面,ref:引用类--&gt;
        &lt;aop:aspect ref=&quot;diy&quot;&gt;
            &lt;!--  切入点--&gt;
            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.hecn.service.UserServiceImpl.*(..))&quot;/&gt;

            &lt;!--通知--&gt;
            &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

            &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;

&lt;/beans&gt;</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="java">import com.hecn.service.UserService;
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class MyTest {
  @Test
  public void tset() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);

    UserService userService = (UserService) context.getBean(&quot;userService&quot;);

    userService.add();
  }
}</code></pre>
<h3 id="方式三：使用注解实现"><a href="#方式三：使用注解实现" class="headerlink" title="方式三：使用注解实现"></a>方式三：使用注解实现</h3><ol>
<li>编写一个注解实现的增强类</li>
</ol>
<pre><code class="java">package com.hecn.diy;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.Signature;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

/** @author 24497 */
@Aspect
public class AnnotationPointCut {

  @Before(value = &quot;execution(* com.hecn.service.UserServiceImpl.*(..))&quot;)
  public void before() {
    System.out.println(&quot;=====方法执行前=====&quot;);
  }

  @After(&quot;execution(* com.hecn.service.UserServiceImpl.*(..))&quot;)
  public void after() {
    System.out.println(&quot;=====方法执行后=====&quot;);
  }

  @Around(value = &quot;execution(* com.hecn.service.UserServiceImpl.*(..))&quot;)
  public void around(ProceedingJoinPoint jp) throws Throwable {
    System.out.println(&quot;环绕前&quot;);

    // 获得签名
    Signature signature = jp.getSignature();

    System.out.println(&quot;signature:&quot; + signature);
    // 执行方法
    Object proceed = jp.proceed();

    System.out.println(&quot;环绕后&quot;);
  }
}</code></pre>
<ol start="2">
<li>在Spring配置文件中，注册bean，并增加支持注解的配置</li>
</ol>
<pre><code class="xml">&lt;!--第三种方式:注解实现--&gt;
&lt;bean id=&quot;annotationPointcut&quot; class=&quot;com.kuang.config.AnnotationPointcut&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;</code></pre>
<pre><code class="xml">通过aop命名空间的&lt;aop:aspectj-autoproxy /&gt;声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被&lt;aop:aspectj-autoproxy /&gt;隐藏起来了 

&lt;aop:aspectj-autoproxy /&gt;有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为&lt;aop:aspectj-autoproxy  poxy-target-class=&quot;true&quot;/&gt;时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</code></pre>
<h1 id="12、整合Mybatis"><a href="#12、整合Mybatis" class="headerlink" title="12、整合Mybatis"></a>12、整合Mybatis</h1><p>步骤：</p>
<ol>
<li><p>导入jar包</p>
<ul>
<li><p>junit 单元测试</p>
<pre><code class="xml">&lt;!--1.junit        --&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;junit&lt;/groupId&gt;
          &lt;artifactId&gt;junit&lt;/artifactId&gt;
          &lt;version&gt;4.13&lt;/version&gt;
      &lt;/dependency&gt;</code></pre>
</li>
<li><p>mybatis</p>
<pre><code class="xml">&lt;!--2.mybatis--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
          &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
          &lt;version&gt;3.5.4&lt;/version&gt;
      &lt;/dependency&gt;</code></pre>
</li>
<li><p>mysql数据库</p>
<pre><code class="xml">&lt;!--3.mysql--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;mysql&lt;/groupId&gt;
          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
          &lt;version&gt;5.1.6&lt;/version&gt;
      &lt;/dependency&gt;</code></pre>
</li>
<li><p>spring相关的</p>
<pre><code class="xml">&lt;!--4.spring相关--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
          &lt;version&gt;5.2.4.RELEASE&lt;/version&gt;
      &lt;/dependency&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
          &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
          &lt;version&gt;5.2.4.RELEASE&lt;/version&gt;
      &lt;/dependency&gt;</code></pre>
</li>
<li><p>aop织入</p>
<pre><code class="java">&lt;!--5.aop织入--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
  &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>mybatis-spring</p>
<pre><code class="xml">&lt;!--6.mybatis-spring--&gt;
      &lt;dependency&gt;
          &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
          &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
          &lt;version&gt;2.0.3&lt;/version&gt;
      &lt;/dependency&gt;</code></pre>
</li>
</ul>
<ol start="2">
<li><p>编写数据源配置</p>
</li>
<li><p>sqlSessionFactory：</p>
</li>
<li><p>sqlSessionTemplate：<code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。<code>SqlSessionTemplate</code> 是线程安全的，可以被多个 DAO 或映射器所共享使用。</p>
</li>
<li><p>给接口加实现类</p>
</li>
<li><p>将自己写的实现类注入到spring容器中</p>
</li>
<li><p>测试</p>
</li>
</ol>
</li>
</ol>
<h1 id="13-Spring-声明式事务"><a href="#13-Spring-声明式事务" class="headerlink" title="13.Spring 声明式事务"></a>13.Spring 声明式事务</h1><h2 id="13-1、事务"><a href="#13-1、事务" class="headerlink" title="13.1、事务"></a>13.1、事务</h2><ul>
<li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li>
<li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li>
</ul>
<p><strong>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</strong></p>
<p><strong>事务四个属性ACID</strong></p>
<ol>
<li>原子性（atomicity）<ul>
<li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li>
</ul>
</li>
<li>一致性（consistency）<ul>
<li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li>
</ul>
</li>
<li>隔离性（isolation）<ul>
<li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li>
</ul>
</li>
<li>持久性（durability）<ul>
<li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li>
</ul>
</li>
</ol>
<h2 id="13-2、spring中的事务管理"><a href="#13-2、spring中的事务管理" class="headerlink" title="13.2、spring中的事务管理"></a>13.2、spring中的事务管理</h2><ul>
<li>声明式事务：（交由容器管理）aop</li>
<li>编程式事务：需要在代码中编写，必须在每个事务操作业务逻辑中包含额外的事务管理代码</li>
</ul>
<p>事务管理器：</p>
<pre><code class="xml">&lt;!--    jdbc事务管理--&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;!--&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;--&gt;
        &lt;constructor-arg ref=&quot;dataSource&quot;/&gt;
    &lt;/bean&gt;</code></pre>
<p>事务通知：</p>
<pre><code class="xml">&lt;!--配置事务通知--&gt;
    &lt;tx:advice id=&quot;interceptor&quot; transaction-manager=&quot;transactionManager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;</code></pre>
<p>配置aop织入：</p>
<pre><code class="xml">&lt;!--配置aop--&gt;
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;execution(* com.hecn.mapper.*.*(..))&quot;/&gt;
        &lt;aop:advisor advice-ref=&quot;interceptor&quot; pointcut-ref=&quot;txPointcut&quot;/&gt;
    &lt;/aop:config&gt;</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/Spring/">Spring</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/Spring/">Spring</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var post = $('#post');
      var toc = $('#toc');
      var tocLimMax = post.offset().top + post.height() - navHeight;

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = $('#board-ctn').css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>










<!-- Plugins -->





  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Spring-Learn&nbsp;",
      ],
      cursorChar: "❤",
      typeSpeed: 70,
      loop: true,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
